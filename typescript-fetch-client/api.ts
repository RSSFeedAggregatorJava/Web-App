/**
 * RSS Feed Aggregator
 * This is an api for \"RSS Feed Aggregator\".  [View Subject](https://intra.epitech.eu/module/2016/M-EAP-650/PAR-9-1/acti-235029/project/file/RSS-feed-aggregator.pdf) or [Messenger group](https://www.messenger.com/t/552069568251252)  A successfull login or signup generate a key usable to authenticate request  This key is owned by one account, a request providing an apiKey should get result for the user owning this key. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://localhost".replace(/\/+$/, '');

export interface FetchArgs {
    url: string;
    options: any; 
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
}

export interface Article {
    "id"?: number;
    "title": string;
    "link"?: string;
    "description"?: string;
    "pubdate"?: Date;
}

export interface Credentials {
    "email": string;
    "password": string;
}

export interface Credentials1 {
    "email": string;
    "password": string;
}

export interface Feed {
    "id"?: number;
    /**
     * url to download feed
     */
    "url": string;
    "title"?: string;
    /**
     * url of blog corresponding to feed
     */
    "link"?: string;
    "description"?: string;
    /**
     * ISO_639-1 language code
     */
    "language"?: string;
}

export interface InlineResponse200 {
    /**
     * used for authenticate future requests
     */
    "apiKey"?: string;
    /**
     * userId for querying related items (feeds...)
     */
    "userId"?: number;
}

export interface User {
    "id"?: number;
    "email": string;
    "password": string;
}



/**
 * ArticleApi - fetch parameter creator
 */
export const ArticleApiFetchParamCreactor = {
    /** 
     * retrieve article feed id and article id (id correspond to 1st, 2nd, 3rd, 4th... article)
     * @param feedId ID of feed containing article
     * @param articleId ID of article to retrieve
     */
    articlesFeedIdArticleIdGet(params: {  feedId: string; articleId: string; }): FetchArgs {
        // verify required parameter "feedId" is set
        if (params["feedId"] == null) {
            throw new Error("Missing required parameter feedId when calling articlesFeedIdArticleIdGet");
        }
        // verify required parameter "articleId" is set
        if (params["articleId"] == null) {
            throw new Error("Missing required parameter articleId when calling articlesFeedIdArticleIdGet");
        }
        const baseUrl = `/articles/{feedId}/{articleId}`
            .replace(`{${"feedId"}}`, `${ params.feedId }`)
            .replace(`{${"articleId"}}`, `${ params.articleId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * ArticleApi - functional programming interface
 */
export const ArticleApiFp = {
    /** 
     * retrieve article feed id and article id (id correspond to 1st, 2nd, 3rd, 4th... article)
     * @param feedId ID of feed containing article
     * @param articleId ID of article to retrieve
     */
    articlesFeedIdArticleIdGet(params: { feedId: string; articleId: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<Article> {
        const fetchArgs = ArticleApiFetchParamCreactor.articlesFeedIdArticleIdGet(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * ArticleApi - object-oriented interface
 */
export class ArticleApi extends BaseAPI {
    /** 
     * retrieve article feed id and article id (id correspond to 1st, 2nd, 3rd, 4th... article)
     * @param feedId ID of feed containing article
     * @param articleId ID of article to retrieve
     */
    articlesFeedIdArticleIdGet(params: {  feedId: string; articleId: string; }) {
        return ArticleApiFp.articlesFeedIdArticleIdGet(params)(this.fetch, this.basePath);
    }
};

/**
 * ArticleApi - factory interface
 */
export const ArticleApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * retrieve article feed id and article id (id correspond to 1st, 2nd, 3rd, 4th... article)
         * @param feedId ID of feed containing article
         * @param articleId ID of article to retrieve
         */
        articlesFeedIdArticleIdGet(params: {  feedId: string; articleId: string; }) {
            return ArticleApiFp.articlesFeedIdArticleIdGet(params)(fetch, basePath);
        },
    }
};


/**
 * FeedApi - fetch parameter creator
 */
export const FeedApiFetchParamCreactor = {
    /** 
     * Unsuscribe to a feed by url (keep it in database, juste remove reference for user)
     * @param feedId ID of feed that user want to unsubscribe
     */
    feedsDelete(params: {  feedId: number; }): FetchArgs {
        // verify required parameter "feedId" is set
        if (params["feedId"] == null) {
            throw new Error("Missing required parameter feedId when calling feedsDelete");
        }
        const baseUrl = `/feeds`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "feedId": params.feedId,
        });
        let fetchOptions: RequestInit = { method: "DELETE" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Find a feed and retrieve its articles
     * Returns id and titles of articles of this feed
     * @param feedId ID of feed that needs to be fetched
     */
    feedsFeedIdGet(params: {  feedId: number; }): FetchArgs {
        // verify required parameter "feedId" is set
        if (params["feedId"] == null) {
            throw new Error("Missing required parameter feedId when calling feedsFeedIdGet");
        }
        const baseUrl = `/feeds/{feedId}`
            .replace(`{${"feedId"}}`, `${ params.feedId }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Get all feeds subscribed by currend user
     */
    feedsGet(): FetchArgs {
        const baseUrl = `/feeds`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Suscribe to a feed by url (add it in database, and reference its id for current user)
     * @param feedUrl url of feed that user want to subscribe
     */
    feedsPost(params: {  feedUrl: string; }): FetchArgs {
        // verify required parameter "feedUrl" is set
        if (params["feedUrl"] == null) {
            throw new Error("Missing required parameter feedUrl when calling feedsPost");
        }
        const baseUrl = `/feeds`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, { 
            "feedUrl": params.feedUrl,
        });
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * FeedApi - functional programming interface
 */
export const FeedApiFp = {
    /** 
     * Unsuscribe to a feed by url (keep it in database, juste remove reference for user)
     * @param feedId ID of feed that user want to unsubscribe
     */
    feedsDelete(params: { feedId: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = FeedApiFetchParamCreactor.feedsDelete(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Find a feed and retrieve its articles
     * Returns id and titles of articles of this feed
     * @param feedId ID of feed that needs to be fetched
     */
    feedsFeedIdGet(params: { feedId: number;  }): (fetch: FetchAPI, basePath?: string) => Promise<Feed> {
        const fetchArgs = FeedApiFetchParamCreactor.feedsFeedIdGet(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Get all feeds subscribed by currend user
     */
    feedsGet(): (fetch: FetchAPI, basePath?: string) => Promise<Array<Feed>> {
        const fetchArgs = FeedApiFetchParamCreactor.feedsGet();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Suscribe to a feed by url (add it in database, and reference its id for current user)
     * @param feedUrl url of feed that user want to subscribe
     */
    feedsPost(params: { feedUrl: string;  }): (fetch: FetchAPI, basePath?: string) => Promise<number> {
        const fetchArgs = FeedApiFetchParamCreactor.feedsPost(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * FeedApi - object-oriented interface
 */
export class FeedApi extends BaseAPI {
    /** 
     * Unsuscribe to a feed by url (keep it in database, juste remove reference for user)
     * @param feedId ID of feed that user want to unsubscribe
     */
    feedsDelete(params: {  feedId: number; }) {
        return FeedApiFp.feedsDelete(params)(this.fetch, this.basePath);
    }
    /** 
     * Find a feed and retrieve its articles
     * Returns id and titles of articles of this feed
     * @param feedId ID of feed that needs to be fetched
     */
    feedsFeedIdGet(params: {  feedId: number; }) {
        return FeedApiFp.feedsFeedIdGet(params)(this.fetch, this.basePath);
    }
    /** 
     * Get all feeds subscribed by currend user
     */
    feedsGet() {
        return FeedApiFp.feedsGet()(this.fetch, this.basePath);
    }
    /** 
     * Suscribe to a feed by url (add it in database, and reference its id for current user)
     * @param feedUrl url of feed that user want to subscribe
     */
    feedsPost(params: {  feedUrl: string; }) {
        return FeedApiFp.feedsPost(params)(this.fetch, this.basePath);
    }
};

/**
 * FeedApi - factory interface
 */
export const FeedApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Unsuscribe to a feed by url (keep it in database, juste remove reference for user)
         * @param feedId ID of feed that user want to unsubscribe
         */
        feedsDelete(params: {  feedId: number; }) {
            return FeedApiFp.feedsDelete(params)(fetch, basePath);
        },
        /** 
         * Find a feed and retrieve its articles
         * Returns id and titles of articles of this feed
         * @param feedId ID of feed that needs to be fetched
         */
        feedsFeedIdGet(params: {  feedId: number; }) {
            return FeedApiFp.feedsFeedIdGet(params)(fetch, basePath);
        },
        /** 
         * Get all feeds subscribed by currend user
         */
        feedsGet() {
            return FeedApiFp.feedsGet()(fetch, basePath);
        },
        /** 
         * Suscribe to a feed by url (add it in database, and reference its id for current user)
         * @param feedUrl url of feed that user want to subscribe
         */
        feedsPost(params: {  feedUrl: string; }) {
            return FeedApiFp.feedsPost(params)(fetch, basePath);
        },
    }
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreactor = {
    /** 
     * Login with email and password
     * 
     * @param credentials credentials
     */
    usersLoginPost(params: {  credentials: Credentials; }): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling usersLoginPost");
        }
        const baseUrl = `/users/login`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Logs out current logged in user session
     * 
     */
    usersLogoutGet(): FetchArgs {
        const baseUrl = `/users/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "GET" };

        let contentTypeHeader: Dictionary<string>;
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /** 
     * Signup with email and password - application/json
     * @param credentials credentials
     */
    usersSignupPost(params: {  credentials: Credentials1; }): FetchArgs {
        // verify required parameter "credentials" is set
        if (params["credentials"] == null) {
            throw new Error("Missing required parameter credentials when calling usersSignupPost");
        }
        const baseUrl = `/users/signup`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = { method: "POST" };

        let contentTypeHeader: Dictionary<string>;
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["credentials"]) {
            fetchOptions.body = JSON.stringify(params["credentials"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = contentTypeHeader;
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
}

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /** 
     * Login with email and password
     * 
     * @param credentials credentials
     */
    usersLoginPost(params: { credentials: Credentials;  }): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = UserApiFetchParamCreactor.usersLoginPost(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Logs out current logged in user session
     * 
     */
    usersLogoutGet(): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreactor.usersLogoutGet();
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /** 
     * Signup with email and password - application/json
     * @param credentials credentials
     */
    usersSignupPost(params: { credentials: Credentials1;  }): (fetch: FetchAPI, basePath?: string) => Promise<InlineResponse200> {
        const fetchArgs = UserApiFetchParamCreactor.usersSignupPost(params);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /** 
     * Login with email and password
     * 
     * @param credentials credentials
     */
    usersLoginPost(params: {  credentials: Credentials; }) {
        return UserApiFp.usersLoginPost(params)(this.fetch, this.basePath);
    }
    /** 
     * Logs out current logged in user session
     * 
     */
    usersLogoutGet() {
        return UserApiFp.usersLogoutGet()(this.fetch, this.basePath);
    }
    /** 
     * Signup with email and password - application/json
     * @param credentials credentials
     */
    usersSignupPost(params: {  credentials: Credentials1; }) {
        return UserApiFp.usersSignupPost(params)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /** 
         * Login with email and password
         * 
         * @param credentials credentials
         */
        usersLoginPost(params: {  credentials: Credentials; }) {
            return UserApiFp.usersLoginPost(params)(fetch, basePath);
        },
        /** 
         * Logs out current logged in user session
         * 
         */
        usersLogoutGet() {
            return UserApiFp.usersLogoutGet()(fetch, basePath);
        },
        /** 
         * Signup with email and password - application/json
         * @param credentials credentials
         */
        usersSignupPost(params: {  credentials: Credentials1; }) {
            return UserApiFp.usersSignupPost(params)(fetch, basePath);
        },
    }
};

